{
  "id" : "ae93d376-c47f-4058-9f46-30b1f26f9940",
  "name" : "api_conferences_dvbe18_rooms_room6_thursday",
  "request" : {
    "url" : "/api/conferences/dvbe18/rooms/Room6/thursday",
    "method" : "GET"
  },
  "response" : {
    "status" : 200,
    "body" : "{\"slots\":[{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542270600000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Architecture & Security\",\"talkType\":\"Conference\",\"track\":\"Architecture & Security.label\",\"audienceLevel\":\"l3\",\"summaryAsHtml\":\"<p>When evaluation different implementation approaches for a set of bounded contexts, a modular, monolithic application constitutes a pragmatic alternative to a microservices architecture that comes with challenges and complexities of a distributed system. Still, in the course of their life time, modularity and maintainability of monolithic applications very often degrade significantly. This is usually caused by the gap between architectural concepts and the codebase implementing those.</p>\\n<p>The talk briefly identifies the commonly observed issues in unstructured monoliths and discusses approaches to code organization and component structure, package design, transactions and the usage of events to implement bounded context interaction. We also take a look at supporting technologies and features of the Spring (Boot) eco-system to easily test individual bounded contexts and detect architectural violations. Attendees will learn how to easily implement architectural concepts into modular, monolithic applications, how to preserve the architecture over time and to prepare a potential split into multiple systems at a later point in time.</p>\\n\",\"id\":\"RMB-6935\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/7c3e49bf489644eeefdd3d85100b474c28c41086\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Oliver Gierke\"},\"name\":\"Oliver Gierke\"}],\"title\":\"Building better monoliths ‚Äì Implementing modulithic applications with Spring\",\"lang\":\"en\",\"summary\":\"When evaluation different implementation approaches for a set of bounded contexts, a modular, monolithic application constitutes a pragmatic alternative to a microservices architecture that comes with challenges and complexities of a distributed system. Still, in the course of their life time, modularity and maintainability of monolithic applications very often degrade significantly. This is usually caused by the gap between architectural concepts and the codebase implementing those.\\r\\n\\r\\nThe talk briefly identifies the commonly observed issues in unstructured monoliths and discusses approaches to code organization and component structure, package design, transactions and the usage of events to implement bounded context interaction. We also take a look at supporting technologies and features of the Spring (Boot) eco-system to easily test individual bounded contexts and detect architectural violations. Attendees will learn how to easily implement architectural concepts into modular, monolithic applications, how to preserve the architecture over time and to prepare a potential split into multiple systems at a later point in time.\"},\"fromTime\":\"09:30\",\"toTimeMillis\":1542273600000,\"toTime\":\"10:20\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_9h30_10h20\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542274800000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Programming languages\",\"talkType\":\"Conference\",\"track\":\"Programming languages.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>GraalVM project enhances the Java ecosystem with an integrated, polyglot, high-performance execution environment for dynamic, static, and native languages. GraalVM supports Java, Scala, Kotlin, Groovy, and other JVM-based languages. At the same time, it can run the dynamic scripting languages JavaScript including node.js, Ruby, R, and Python.</p>\\n<p>In this session you'll see demos and learn what you can do with GraalVM, from using it as the JVM JIT compiler, enhancing the JIT, running native and polyglot programs, compiling them ahead of time for faster startup and lower runtime overhead, debugging your polyglot code using exact same tools for any language, to profiling performance and memory of your application and embedding GraalVM in a native application for portability.</p>\\n<p>GraalVM offers you the opportunity to write the code in the language you want, which suits the problem the best, and run the resulting program really fast wherever you like: JVM, native code, even inside a database.</p>\\n\",\"id\":\"FNS-6849\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/e43a02ca20691173da1dc75a12a7a030f72c13c0\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Oleg ≈†elajev\"},\"name\":\"Oleg ≈†elajev\"},{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/9d24c928e91ac666d17dca940a22448bc4b49eab\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Thomas Wuerthinger\"},\"name\":\"Thomas Wuerthinger\"}],\"title\":\"GraalVM: Run Programs Faster Anywhere\",\"lang\":\"en\",\"summary\":\"GraalVM project enhances the Java ecosystem with an integrated, polyglot, high-performance execution environment for dynamic, static, and native languages. GraalVM supports Java, Scala, Kotlin, Groovy, and other JVM-based languages. At the same time, it can run the dynamic scripting languages JavaScript including node.js, Ruby, R, and Python. \\r\\n\\r\\nIn this session you'll see demos and learn what you can do with GraalVM, from using it as the JVM JIT compiler, enhancing the JIT, running native and polyglot programs, compiling them ahead of time for faster startup and lower runtime overhead, debugging your polyglot code using exact same tools for any language, to profiling performance and memory of your application and embedding GraalVM in a native application for portability. \\r\\n\\r\\nGraalVM offers you the opportunity to write the code in the language you want, which suits the problem the best, and run the resulting program really fast wherever you like: JVM, native code, even inside a database. \"},\"fromTime\":\"10:40\",\"toTimeMillis\":1542277800000,\"toTime\":\"11:30\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_10h40_11h30\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542279000000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Architecture & Security\",\"talkType\":\"Conference\",\"track\":\"Architecture & Security.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>Integrating microservices and taming distributed systems is hard. In this talk I will present three challenges I've observed in real-life projects and discuss how to avoid them.</p>\\n<ol>\\n<li><p>Communication is complex. With everything being distributed failures are normal so you need sophisticated failure handling strategies (e.g. stateful retry).</p>\\n</li>\\n<li><p>Asynchronicity requires you to handle timeouts. This is not only about milliseconds, systems get much more resilient when you can wait for minutes, hours or even longer.</p>\\n</li>\\n<li><p>Distributed transactions cannot simply be delegated to protocols like XA. So you need to solve the requirement to retain consistency in case of failures.</p>\\n</li>\\n</ol>\\n<p>I will not only use slides but also demonstrate concrete source code examples available on GitHub.</p>\\n\",\"id\":\"BIP-8983\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/770d49323c90aafdad5c67c770ff25fba9102a42\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Bernd R√ºcker\"},\"name\":\"Bernd R√ºcker\"}],\"title\":\"3 common pitfalls in microservice integration and how to avoid them\",\"lang\":\"en\",\"summary\":\"Integrating microservices and taming distributed systems is hard. In this talk I will present three challenges I've observed in real-life projects and discuss how to avoid them.\\r\\n\\r\\n1. Communication is complex. With everything being distributed failures are normal so you need sophisticated failure handling strategies (e.g. stateful retry).\\r\\n\\r\\n2. Asynchronicity requires you to handle timeouts. This is not only about milliseconds, systems get much more resilient when you can wait for minutes, hours or even longer.\\r\\n\\r\\n3. Distributed transactions cannot simply be delegated to protocols like XA. So you need to solve the requirement to retain consistency in case of failures.\\r\\n\\r\\nI will not only use slides but also demonstrate concrete source code examples available on GitHub.\"},\"fromTime\":\"11:50\",\"toTimeMillis\":1542282000000,\"toTime\":\"12:40\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_11h50_12h40\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542282900000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Methodology & Culture\",\"talkType\":\"Quickie\",\"track\":\"Methodology & Culture.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>Do you practice TDD? What about BDD? What about H (Hypothesis) DD?</p>\\n<p>Did you know that SDD (Stackoverflow Driven Development) is a thing? What about Fowler Driven Development or Beer Driven Development?</p>\\n<p>I spent some time working with some colleagues on the A to Z of *DD. The result was a full alphabet of things that at least one of us had experienced during our careers. Some serious, some less so, some good, some undeniably indifferent to bad to plain stupid.</p>\\n<p>But out of all of this I wondered what should REALLY drive our development? In this lightning trip around the alphabet of absurdity I will tell you the one guiding principal that we should all stick to when deciding what should drive our development.</p>\\n\",\"id\":\"ZWW-0582\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/6abf170c2f14b452300d5b52df6818afcb6fcccf\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"James Birnie\"},\"name\":\"James Birnie\"}],\"title\":\"What Drives your Development?\",\"lang\":\"en\",\"summary\":\"Do you practice TDD? What about BDD? What about H (Hypothesis) DD?\\r\\n\\r\\nDid you know that SDD (Stackoverflow Driven Development) is a thing? What about Fowler Driven Development or Beer Driven Development?\\r\\n\\r\\nI spent some time working with some colleagues on the A to Z of *DD. The result was a full alphabet of things that at least one of us had experienced during our careers. Some serious, some less so, some good, some undeniably indifferent to bad to plain stupid.\\r\\n\\r\\nBut out of all of this I wondered what should REALLY drive our development? In this lightning trip around the alphabet of absurdity I will tell you the one guiding principal that we should all stick to when deciding what should drive our development.\"},\"fromTime\":\"12:55\",\"toTimeMillis\":1542283800000,\"toTime\":\"13:10\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"quick_Room6_thursday_15_12h55_13h10\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542284400000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Methodology & Culture\",\"talkType\":\"Quickie\",\"track\":\"Methodology & Culture.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>One of the challenges in engineering a software product today is to minimize the amount of code that needs to be duplicated to support the app on multiple platforms. This challenge is partly due to APIs that expose data as opposed to business content. With data-driven APIs the app must embed large chunks of the business logic. First, it must transform the data into content to display. Second, it must transform it back into data to be processed by the API. While solutions exist to share this transformation logic between multiple app platforms, we decided to host this logic on the server.</p>\\n<p>This is achieved by exposing a presentation API containing use case specific endpoints. Its responses have the content matching the needs of what is displayed by the app. This decision of building the product around a presentation API has served us well in this project. Throughout the life of our project, we have had the opportunity to exploit the presentation layer in the backend. This allowed us to iterate faster with the product by displaying different things without having to ship any new code to the front end, while reducing the apps development time.</p>\\n\",\"id\":\"GMH-7709\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/5dd5aacbde402a87bc425d45db189d9ce7f2dd5d\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Antoine Tollenaere\"},\"name\":\"Antoine Tollenaere\"},{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/fff0c5b6085b5805cbba76d0de3e08fcbb384e5d\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Ricardo Lage\"},\"name\":\"Ricardo Lage\"}],\"title\":\"Centralizing Business Logic on the Server: How We Designed Presentation APIs\",\"lang\":\"en\",\"summary\":\"One of the challenges in engineering a software product today is to minimize the amount of code that needs to be duplicated to support the app on multiple platforms. This challenge is partly due to APIs that expose data as opposed to business content. With data-driven APIs the app must embed large chunks of the business logic. First, it must transform the data into content to display. Second, it must transform it back into data to be processed by the API. While solutions exist to share this transformation logic between multiple app platforms, we decided to host this logic on the server. \\r\\n\\r\\nThis is achieved by exposing a presentation API containing use case specific endpoints. Its responses have the content matching the needs of what is displayed by the app. This decision of building the product around a presentation API has served us well in this project. Throughout the life of our project, we have had the opportunity to exploit the presentation layer in the backend. This allowed us to iterate faster with the product by displaying different things without having to ship any new code to the front end, while reducing the apps development time.\"},\"fromTime\":\"13:20\",\"toTimeMillis\":1542285300000,\"toTime\":\"13:35\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"quick_Room6_thursday_15_13h20_13h35\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542286200000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Server Side Java\",\"talkType\":\"Conference\",\"track\":\"Server Side Java.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>In this session, the creator of Micronaut and Grails introduces the newly released Micronaut framework and demonstrates how Micronaut‚Äôs unique compile-time approach enables the development of ultra-lightweight microservices for Java. Compelling aspects of the Micronaut framework include</p>\\n<ul>\\n<li>Subsecond startup time</li>\\n<li>Small processes that can run in as little as 10 MB of JVM heap</li>\\n<li>No runtime reflection</li>\\n<li>Dependency injection and AOP ‚Ä¢ Cloud Native</li>\\n</ul>\\n<p>Graeme will also demonstrate how you can take your Microservices to the next level by using Micronaut's Ahead of Time Compilation (AOT) support and Oracle's GraalVM to achieve instant startup and ultra-low memory footprint.</p>\\n\",\"id\":\"BZV-3566\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/d0e5ed79b2bbac20686a75dfe162c459ab1998fd\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Graeme Rocher\"},\"name\":\"Graeme Rocher\"}],\"title\":\"Introduction to Micronaut: Lightweight Microservices with Ahead of Time Compilation\",\"lang\":\"en\",\"summary\":\"In this session, the creator of Micronaut and Grails introduces the newly released Micronaut framework and demonstrates how Micronaut‚Äôs unique compile-time approach enables the development of ultra-lightweight microservices for Java. Compelling aspects of the Micronaut framework include\\r\\n\\r\\n* Subsecond startup time\\r\\n* Small processes that can run in as little as 10 MB of JVM heap\\r\\n* No runtime reflection\\r\\n* Dependency injection and AOP ‚Ä¢ Cloud Native\\r\\n\\r\\nGraeme will also demonstrate how you can take your Microservices to the next level by using Micronaut's Ahead of Time Compilation (AOT) support and Oracle's GraalVM to achieve instant startup and ultra-low memory footprint.\"},\"fromTime\":\"13:50\",\"toTimeMillis\":1542289200000,\"toTime\":\"14:40\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_13h50_14h40\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542290400000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Cloud, Containers & Infrastructure\",\"talkType\":\"Conference\",\"track\":\"Cloud, Containers & Infrastructure.label\",\"audienceLevel\":\"l2\",\"summaryAsHtml\":\"<p>Having a self-service based infrastructure platform is crucial for the adoption of DevOps culture and capabilities. Within Nationale Nederlanden, a large international insurance company, we offer a compliant and easy to use platform across more than 50 AWS accounts, to be used by over 200 teams worldwide. Providing an enterprise scale, highly regulated, cloud platform and a range of CI/CD tools at this scale is not without challenges. We will take you on our journey that we started 2 years ago. We will share the problems and pitfalls we experienced as a team and explain how we tackled them. We will also teach how we kept ourselves from drowning in operations work and achieved to deliver more, while worrying less. Our journey will include lessons on:</p>\\n<ul>\\n<li>Setting up infrastructure as code in a scalable way</li>\\n<li>Running and deploying many pipelines over numerous AWS accounts</li>\\n<li>Providing your customers with tools that they can consume in a self-service way across accounts.</li>\\n</ul>\\n<p>During the talk we hope to inspire you to achieve full automation and leave the session with a unique take on solving CI/CD at scale.</p>\\n\",\"id\":\"QZY-5499\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/07162e8d688cbca41c7415ebea3164603f30dd08\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Jaap Kabbedijk\"},\"name\":\"Jaap Kabbedijk\"},{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/1fb4b36067019650b169a5514fb1908292305c35\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Gijsbert van Renswoude\"},\"name\":\"Gijsbert van Renswoude\"}],\"title\":\"Managing CI/CD on AWS at scale\",\"lang\":\"en\",\"summary\":\"Having a self-service based infrastructure platform is crucial for the adoption of DevOps culture and capabilities. Within Nationale Nederlanden, a large international insurance company, we offer a compliant and easy to use platform across more than 50 AWS accounts, to be used by over 200 teams worldwide. Providing an enterprise scale, highly regulated, cloud platform and a range of CI/CD tools at this scale is not without challenges. We will take you on our journey that we started 2 years ago. We will share the problems and pitfalls we experienced as a team and explain how we tackled them. We will also teach how we kept ourselves from drowning in operations work and achieved to deliver more, while worrying less. Our journey will include lessons on:\\r\\n \\r\\n* Setting up infrastructure as code in a scalable way\\r\\n* Running and deploying many pipelines over numerous AWS accounts\\r\\n* Providing your customers with tools that they can consume in a self-service way across accounts.\\r\\n \\r\\nDuring the talk we hope to inspire you to achieve full automation and leave the session with a unique take on solving CI/CD at scale.\"},\"fromTime\":\"15:00\",\"toTimeMillis\":1542293400000,\"toTime\":\"15:50\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_15h0_15h50\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542295800000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Architecture & Security\",\"talkType\":\"Conference\",\"track\":\"Architecture & Security.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>HTTP cookies are everyhere. Not a single day without having to approve a cookie banner consent. Not so much projects without them and yet, we often don‚Äôt really get how they work.</p>\\n<p>We mix-up the rules they have to follow in the browsers. We‚Äôre confusing them with server side sessions. Those holes, in the giant skillset any modern developer should have, sometimes have non negligible impacts on the security of our apps and on our privacy as simple users of the Web.</p>\\n<p>In this session, we‚Äôll have a (re)discovery of HTTP cookies through examples and live demos. We‚Äôll go back to the very basics: their origins and their behaviour inside our browsers. We‚Äôll finish by talking about more recent news around cookies (SameSite, cookie prefix) and how they‚Äôre used by modern Web APIs like fetch(). This talk will also be a good opportunity to talk about security, tracking and privacy in general.</p>\\n\",\"id\":\"JME-2806\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/8a840a35dc6946fe9d5eaf0c0910a53afadaf981\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Hubert SABLONNI√àRE\"},\"name\":\"Hubert SABLONNI√àRE\"}],\"title\":\"#BackToBasics : üç™ HTTP cookies\",\"lang\":\"en\",\"summary\":\"HTTP cookies are everyhere. Not a single day without having to approve a cookie banner consent. Not so much projects without them and yet, we often don‚Äôt really get how they work.\\r\\n\\r\\nWe mix-up the rules they have to follow in the browsers. We‚Äôre confusing them with server side sessions. Those holes, in the giant skillset any modern developer should have, sometimes have non negligible impacts on the security of our apps and on our privacy as simple users of the Web.\\r\\n\\r\\nIn this session, we‚Äôll have a (re)discovery of HTTP cookies through examples and live demos. We‚Äôll go back to the very basics: their origins and their behaviour inside our browsers. We‚Äôll finish by talking about more recent news around cookies (SameSite, cookie prefix) and how they‚Äôre used by modern Web APIs like fetch(). This talk will also be a good opportunity to talk about security, tracking and privacy in general.\"},\"fromTime\":\"16:30\",\"toTimeMillis\":1542298800000,\"toTime\":\"17:20\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_16h30_17h20\",\"day\":\"thursday\"},{\"roomId\":\"Room6\",\"notAllocated\":false,\"fromTimeMillis\":1542300000000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Cloud, Containers & Infrastructure\",\"talkType\":\"Conference\",\"track\":\"Cloud, Containers & Infrastructure.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>So, you‚Äôve fully embraced the container revolution, and you are now deploying all of the Java applications packaged in Docker containers, but are you taking appropriate caution with the new security issues container technology can bring? Join Steve and Daniel for an overview of the current threat landscape, with a focus on container technology and Java applications, and learn how to mitigate the risks. Hear about the impact of security throughout the software creation and delivery lifecycle, how container technology changes and adds to the security requirements of modern software and learn about the important open source tools for code scanning and dependency verification etc and guidelines on when to use them</p>\\n\",\"id\":\"NAR-5215\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/cdf458af94a18a9ad4553fab5ae89c87483cedc6\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Daniel Bryant\"},\"name\":\"Daniel Bryant\"},{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/7054204a63b211dd9f47c9cb0a600da878c3b9ce\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Steve Poole\"},\"name\":\"Steve Poole\"}],\"title\":\"Are You Deploying and Operating with Security in Mind? Cloud, Containers and Collateral Damage\",\"lang\":\"en\",\"summary\":\"So, you‚Äôve fully embraced the container revolution, and you are now deploying all of the Java applications packaged in Docker containers, but are you taking appropriate caution with the new security issues container technology can bring? Join Steve and Daniel for an overview of the current threat landscape, with a focus on container technology and Java applications, and learn how to mitigate the risks. Hear about the impact of security throughout the software creation and delivery lifecycle, how container technology changes and adds to the security requirements of modern software and learn about the important open source tools for code scanning and dependency verification etc and guidelines on when to use them\"},\"fromTime\":\"17:40\",\"toTimeMillis\":1542303000000,\"toTime\":\"18:30\",\"roomCapacity\":370,\"roomName\":\"Room 6\",\"slotId\":\"conf_Room6_thursday_15_17h40_18h30\",\"day\":\"thursday\"}]}",
    "headers" : {
      "Content-Type" : "application/json; charset=utf-8",
      "Etag" : "v2-791456271764484823",
      "Links" : "<http://dvbe18.confinabox.com/api/profile/schedule>; rel=\"profile\"",
      "Vary" : "Accept-Encoding",
      "X-No-Access" : "no-origin",
      "Date" : "Wed, 15 May 2019 10:17:37 GMT"
    }
  },
  "uuid" : "ae93d376-c47f-4058-9f46-30b1f26f9940",
  "persistent" : true,
  "insertionIndex" : 177
}