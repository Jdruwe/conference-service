{
  "id" : "1cfebeb3-86c4-44dc-ad1b-7bd67eeddd90",
  "name" : "api_conferences_dvbe18_rooms_room5_friday",
  "request" : {
    "url" : "/api/conferences/dvbe18/rooms/Room5/friday",
    "method" : "GET"
  },
  "response" : {
    "status" : 200,
    "body" : "{\"slots\":[{\"roomId\":\"Room5\",\"notAllocated\":false,\"fromTimeMillis\":1542357000000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Architecture & Security\",\"talkType\":\"Conference\",\"track\":\"Architecture & Security.label\",\"audienceLevel\":\"l2\",\"summaryAsHtml\":\"<p>If WhatsApp can do it, why not you?\\nIn this talk, we present a practical architecture for end-to-end encrypted (E2EE) apps, its benefits, consequences and the main pitfalls to avoid. We will use the open source DataPeps SDK to automate the implementation of cryptography and apply DataPeps to secure a sample note-taking app with the implementation of E2EE. In doing so, we will not change  the user experience the slightest. The Note app we chose has a backend implemented in Go and a frontend implemented in JavaScript, but similar code can be used with other programming languages. Fifty minutes is all we need to detail how to create a secure session in which data is automatically encrypted and decrypted on the client-side, and use that session to protect individual notes and share notes between different users.</p>\\n\",\"id\":\"RSV-7655\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/14140d38392a8d13e9a6b956b3854c9fca117eb3\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Henri Binsztok\"},\"name\":\"Henri Binsztok\"}],\"title\":\"Implement End-to-End Encryption in Your App in Just 50 Minutes\",\"lang\":\"en\",\"summary\":\"If WhatsApp can do it, why not you? \\r\\nIn this talk, we present a practical architecture for end-to-end encrypted (E2EE) apps, its benefits, consequences and the main pitfalls to avoid. We will use the open source DataPeps SDK to automate the implementation of cryptography and apply DataPeps to secure a sample note-taking app with the implementation of E2EE. In doing so, we will not change  the user experience the slightest. The Note app we chose has a backend implemented in Go and a frontend implemented in JavaScript, but similar code can be used with other programming languages. Fifty minutes is all we need to detail how to create a secure session in which data is automatically encrypted and decrypted on the client-side, and use that session to protect individual notes and share notes between different users.\\r\\n\"},\"fromTime\":\"09:30\",\"toTimeMillis\":1542360000000,\"toTime\":\"10:20\",\"roomCapacity\":649,\"roomName\":\"Room 5\",\"slotId\":\"conf_Room5_friday_16_9h30_10h20\",\"day\":\"friday\"},{\"roomId\":\"Room5\",\"notAllocated\":false,\"fromTimeMillis\":1542360900000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Cloud, Containers & Infrastructure\",\"talkType\":\"Conference\",\"track\":\"Cloud, Containers & Infrastructure.label\",\"audienceLevel\":\"l2\",\"summaryAsHtml\":\"<p>Working with complex systems means that even well written code can behave in unexpected ways, leading to outages and critical issues. Kubernetes allows you to easily rollout new code and quickly revert to safe, stable releases when issues are identified. But often the damage done in the short period between deploy and rollback is significant.</p>\\n<p>In this session, we’ll show you how to limit the effect of unforeseen issues using canary deploys with Istio. We’ll also cover ways to better monitor your applications in Kubernetes to help you spot potential problems before they affect your entire customer base.</p>\\n\",\"id\":\"MVM-1794\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/b1852252dc6c0770967861a5f00482bc4e5d2444\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Jason Yee\"},\"name\":\"Jason Yee\"}],\"title\":\"Better Canary Deploys with Kubernetes and Istio\",\"lang\":\"en\",\"summary\":\"Working with complex systems means that even well written code can behave in unexpected ways, leading to outages and critical issues. Kubernetes allows you to easily rollout new code and quickly revert to safe, stable releases when issues are identified. But often the damage done in the short period between deploy and rollback is significant.\\r\\n\\r\\nIn this session, we’ll show you how to limit the effect of unforeseen issues using canary deploys with Istio. We’ll also cover ways to better monitor your applications in Kubernetes to help you spot potential problems before they affect your entire customer base.\\r\\n\"},\"fromTime\":\"10:35\",\"toTimeMillis\":1542363900000,\"toTime\":\"11:25\",\"roomCapacity\":649,\"roomName\":\"Room 5\",\"slotId\":\"conf_Room5_friday_16_10h35_11h25\",\"day\":\"friday\"},{\"roomId\":\"Room5\",\"notAllocated\":false,\"fromTimeMillis\":1542364800000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Java Language\",\"talkType\":\"Conference\",\"track\":\"Java Language.label\",\"audienceLevel\":\"l2\",\"summaryAsHtml\":\"<p>The Z Garbage Collector (ZGC) is a new JDK garbage collector designed for low latency and high scalability.  For an industry-standard latency-sensitive benchmark it achieves throughput over 36% higher than the existing JDK collectors while never exceeding a maximum pause time of two milliseconds.  In this session we’ll explain how ZGC achieves this performance, and show how to use it.</p>\\n\",\"id\":\"DPN-3235\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/51bea6ea1f0db004b7ecebf43745df84424cac32\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Erik Österlund\"},\"name\":\"Erik Österlund\"}],\"title\":\"The Z Garbage Collector\",\"lang\":\"en\",\"summary\":\"The Z Garbage Collector (ZGC) is a new JDK garbage collector designed for low latency and high scalability.  For an industry-standard latency-sensitive benchmark it achieves throughput over 36% higher than the existing JDK collectors while never exceeding a maximum pause time of two milliseconds.  In this session we’ll explain how ZGC achieves this performance, and show how to use it.\"},\"fromTime\":\"11:40\",\"toTimeMillis\":1542367800000,\"toTime\":\"12:30\",\"roomCapacity\":649,\"roomName\":\"Room 5\",\"slotId\":\"conf_Room5_friday_16_11h40_12h30\",\"day\":\"friday\"}]}",
    "headers" : {
      "Content-Type" : "application/json; charset=utf-8",
      "Etag" : "v2-791456261406005538",
      "Links" : "<http://dvbe18.confinabox.com/api/profile/schedule>; rel=\"profile\"",
      "Vary" : "Accept-Encoding",
      "X-No-Access" : "no-origin",
      "Date" : "Wed, 15 May 2019 10:17:27 GMT"
    }
  },
  "uuid" : "1cfebeb3-86c4-44dc-ad1b-7bd67eeddd90",
  "persistent" : true,
  "insertionIndex" : 62
}