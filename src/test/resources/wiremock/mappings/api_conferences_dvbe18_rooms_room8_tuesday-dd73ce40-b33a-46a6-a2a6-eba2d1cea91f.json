{
  "id" : "dd73ce40-b33a-46a6-a2a6-eba2d1cea91f",
  "name" : "api_conferences_dvbe18_rooms_room8_tuesday",
  "request" : {
    "url" : "/api/conferences/dvbe18/rooms/Room8/tuesday",
    "method" : "GET"
  },
  "response" : {
    "status" : 200,
    "body" : "{\"slots\":[{\"roomId\":\"Room8\",\"notAllocated\":false,\"fromTimeMillis\":1542097800000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Java Language\",\"talkType\":\"Deep Dive\",\"track\":\"Java Language.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>What is the state of lambda expressions in Java 11? Lambda expressions are the major feature of Java 8, having an impact on most of the API, including the Streams and Collections API. We are now living the Java 11 days; new features have been added and new patterns have emerged. This highly technical Deep Dive session will visit all these patterns, the well-known ones and the new ones, in an interactive hybrid of lecture and laboratory. We present a technique and show how it helps solve a problem. We then present another problem, and give you some time to solve it yourself. Finally, we present a solution, and open for questions, comments, and discussion. Bring your laptop set up with JDK 11 and your favorite IDE, and be prepared to think!</p>\\n<p>This session is part 2 of 2 parts. In part 2 we will cover techniques for using streams, Optional, and Collectors.</p>\\n\",\"id\":\"BLI-5468\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/e14ef4212ffd330e97f9a0ff3420fc27714d4b0d\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"José Paumard\"},\"name\":\"José Paumard\"},{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/a733dc53923e5acd86780590978c563ce1e2582e\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Stuart Marks\"},\"name\":\"Stuart Marks\"}],\"title\":\"Lambdas and Streams Master Class Part 2\",\"lang\":\"en\",\"summary\":\"What is the state of lambda expressions in Java 11? Lambda expressions are the major feature of Java 8, having an impact on most of the API, including the Streams and Collections API. We are now living the Java 11 days; new features have been added and new patterns have emerged. This highly technical Deep Dive session will visit all these patterns, the well-known ones and the new ones, in an interactive hybrid of lecture and laboratory. We present a technique and show how it helps solve a problem. We then present another problem, and give you some time to solve it yourself. Finally, we present a solution, and open for questions, comments, and discussion. Bring your laptop set up with JDK 11 and your favorite IDE, and be prepared to think!\\r\\n\\r\\nThis session is part 2 of 2 parts. In part 2 we will cover techniques for using streams, Optional, and Collectors.\"},\"fromTime\":\"09:30\",\"toTimeMillis\":1542108600000,\"toTime\":\"12:30\",\"roomCapacity\":694,\"roomName\":\"Room 8\",\"slotId\":\"uni_Room8_tuesday_13_9h30_12h30\",\"day\":\"tuesday\"},{\"roomId\":\"Room8\",\"notAllocated\":false,\"fromTimeMillis\":1542112200000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Architecture & Security\",\"talkType\":\"Deep Dive\",\"track\":\"Architecture & Security.label\",\"audienceLevel\":\"l3\",\"summaryAsHtml\":\"<p>Teams that have built monoliths for years are used to certain patterns of interaction between different parts of the code base. Simply replicating those patterns when splitting up a system into a distributed one usually introduces a lot of complexity and drawbacks that often totally subvert the desired effects of a split up of the system in the first place.</p>\\n<p>The talk takes a look at a concrete sample of monolithic module interactions and identifies the problems that arise if that approach is transferred as-is into a distributed system. We then discuss an alternative variant of the monolithic implementation and how that approach improves the system's modularity for the monolith and how it minimizes the cost and problems when splitting up the monolith or even starting with a system of systems in the first place.</p>\\n\",\"id\":\"MTM-6628\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/7c3e49bf489644eeefdd3d85100b474c28c41086\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Oliver Gierke\"},\"name\":\"Oliver Gierke\"}],\"title\":\"Refactoring to a System of Systems\",\"lang\":\"en\",\"summary\":\"Teams that have built monoliths for years are used to certain patterns of interaction between different parts of the code base. Simply replicating those patterns when splitting up a system into a distributed one usually introduces a lot of complexity and drawbacks that often totally subvert the desired effects of a split up of the system in the first place.\\r\\n\\r\\nThe talk takes a look at a concrete sample of monolithic module interactions and identifies the problems that arise if that approach is transferred as-is into a distributed system. We then discuss an alternative variant of the monolithic implementation and how that approach improves the system's modularity for the monolith and how it minimizes the cost and problems when splitting up the monolith or even starting with a system of systems in the first place.\"},\"fromTime\":\"13:30\",\"toTimeMillis\":1542123000000,\"toTime\":\"16:30\",\"roomCapacity\":694,\"roomName\":\"Room 8\",\"slotId\":\"uni_Room8_tuesday_13_13h30_16h30\",\"day\":\"tuesday\"},{\"roomId\":\"Room8\",\"notAllocated\":false,\"fromTimeMillis\":1542123900000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Cloud, Containers & Infrastructure\",\"talkType\":\"Tools-in-Action\",\"track\":\"Cloud, Containers & Infrastructure.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>Spring Boot is awesome. Docker is awesome. Together you can do great things. But, are you doing it the right way? We'll walk you through, in detail, the optimal way to structure Docker images for Spring Boot applications for iterative development. Structuring your Docker images correctly is really important for teams doing continuous integration and continuous delivery. Using Docker best practices, we'll show you the code and the technologies used to optimize Docker images for Spring Boot apps!</p>\\n\",\"id\":\"LJT-6211\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/8107d6242333f09d50f5cabe954fa611c2215c31\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Mike Thompson\"},\"name\":\"Mike Thompson\"},{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/ac63ccacfadd16102fe70327a20e2faa6933bca6\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Graham Charters\"},\"name\":\"Graham Charters\"}],\"title\":\"Optimizing Spring Boot apps for Docker\",\"lang\":\"en\",\"summary\":\"Spring Boot is awesome. Docker is awesome. Together you can do great things. But, are you doing it the right way? We'll walk you through, in detail, the optimal way to structure Docker images for Spring Boot applications for iterative development. Structuring your Docker images correctly is really important for teams doing continuous integration and continuous delivery. Using Docker best practices, we'll show you the code and the technologies used to optimize Docker images for Spring Boot apps!\\r\\n\"},\"fromTime\":\"16:45\",\"toTimeMillis\":1542125700000,\"toTime\":\"17:15\",\"roomCapacity\":694,\"roomName\":\"Room 8\",\"slotId\":\"tia_Room8_tuesday_13_16h45_17h15\",\"day\":\"tuesday\"},{\"roomId\":\"Room8\",\"notAllocated\":false,\"fromTimeMillis\":1542126600000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Cloud, Containers & Infrastructure\",\"talkType\":\"Tools-in-Action\",\"track\":\"Cloud, Containers & Infrastructure.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>Have you ever thought that you needed to be a programmer to do stream processing and build streaming data pipelines? Think again! Apache Kafka is a distributed, scalable, and fault-tolerant streaming platform, providing low-latency pub-sub messaging coupled with native storage and stream processing capabilities. Integrating Kafka with RDBMS, NoSQL, and object stores is simple with Kafka Connect, which is part of Apache Kafka. KSQL is the open-source SQL streaming engine for Apache Kafka, and makes it possible to build stream processing applications at scale, written using a familiar SQL interface.</p>\\n<p>In this talk we’ll explain the architectural reasoning for Apache Kafka and the benefits of real-time integration, and we’ll build a streaming data pipeline using nothing but our bare hands, Kafka Connect, and KSQL.</p>\\n<p>Gasp as we filter events in real time! Be amazed at how we can enrich streams of data with data from RDBMS! Be astonished at the power of streaming aggregates for anomaly detection!</p>\\n\",\"id\":\"BVD-3316\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/813877751b36813246ddf5336298adb8047ead5d\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Robin Moffatt\"},\"name\":\"Robin Moffatt\"}],\"title\":\"Apache Kafka and KSQL in Action : Let’s Build a Streaming Data Pipeline!\",\"lang\":\"en\",\"summary\":\"Have you ever thought that you needed to be a programmer to do stream processing and build streaming data pipelines? Think again! Apache Kafka is a distributed, scalable, and fault-tolerant streaming platform, providing low-latency pub-sub messaging coupled with native storage and stream processing capabilities. Integrating Kafka with RDBMS, NoSQL, and object stores is simple with Kafka Connect, which is part of Apache Kafka. KSQL is the open-source SQL streaming engine for Apache Kafka, and makes it possible to build stream processing applications at scale, written using a familiar SQL interface.\\r\\n\\r\\nIn this talk we’ll explain the architectural reasoning for Apache Kafka and the benefits of real-time integration, and we’ll build a streaming data pipeline using nothing but our bare hands, Kafka Connect, and KSQL.\\r\\n\\r\\nGasp as we filter events in real time! Be amazed at how we can enrich streams of data with data from RDBMS! Be astonished at the power of streaming aggregates for anomaly detection!\"},\"fromTime\":\"17:30\",\"toTimeMillis\":1542128400000,\"toTime\":\"18:00\",\"roomCapacity\":694,\"roomName\":\"Room 8\",\"slotId\":\"tia_Room8_tuesday_13_17h30_18h0\",\"day\":\"tuesday\"},{\"roomId\":\"Room8\",\"notAllocated\":false,\"fromTimeMillis\":1542129300000,\"break\":null,\"roomSetup\":\"classroom\",\"talk\":{\"trackId\":\"Architecture & Security\",\"talkType\":\"Tools-in-Action\",\"track\":\"Architecture & Security.label\",\"audienceLevel\":\"l1\",\"summaryAsHtml\":\"<p>44% of applications contain critical vulnerabilities in an open source component*\\nand this although good practices like OWASP Top 10 have become widespread.</p>\\n<p>Do not let these vulnerabilities incubate warm in the belly of your app! With this talk you'll learn how those vulnerabilities are indexed  (NVD, CVE) and how their severity is scored (CVSS).</p>\\n<p>You'll see how to create your first Continuous Security pipeline using Jenkins and OWASP DependencyCheck which detects vulnerabilities and track them using OWASP DependencyTrack (open-source softwares)</p>\\n<p>Do you first step in the DevSecOps philosophy !!!</p>\\n<p>*https://www.veracode.com/products/software-composition-analysis</p>\\n\",\"id\":\"FSN-9751\",\"speakers\":[{\"link\":{\"href\":\"http://dvbe18.confinabox.com/api/conferences/dvbe18/speakers/f325eea5554d5773dbcb919b9e59b551571910be\",\"rel\":\"http://dvbe18.confinabox.com/api/profile/speaker\",\"title\":\"Julien Topçu\"},\"name\":\"Julien Topçu\"}],\"title\":\"Find and Track the hidden vulnerabilities inside your dependencies\",\"lang\":\"en\",\"summary\":\"44% of applications contain critical vulnerabilities in an open source component* \\r\\nand this although good practices like OWASP Top 10 have become widespread.\\r\\n\\r\\n\\r\\n\\r\\nDo not let these vulnerabilities incubate warm in the belly of your app! With this talk you'll learn how those vulnerabilities are indexed  (NVD, CVE) and how their severity is scored (CVSS).\\r\\n\\r\\nYou'll see how to create your first Continuous Security pipeline using Jenkins and OWASP DependencyCheck which detects vulnerabilities and track them using OWASP DependencyTrack (open-source softwares)\\r\\n\\r\\nDo you first step in the DevSecOps philosophy !!!\\r\\n\\r\\n*https://www.veracode.com/products/software-composition-analysis\"},\"fromTime\":\"18:15\",\"toTimeMillis\":1542131100000,\"toTime\":\"18:45\",\"roomCapacity\":694,\"roomName\":\"Room 8\",\"slotId\":\"tia_Room8_tuesday_13_18h15_18h45\",\"day\":\"tuesday\"}]}",
    "headers" : {
      "Content-Type" : "application/json; charset=utf-8",
      "Etag" : "v2-791456299257604",
      "Links" : "<http://dvbe18.confinabox.com/api/profile/schedule>; rel=\"profile\"",
      "Vary" : "Accept-Encoding",
      "X-No-Access" : "no-origin",
      "Date" : "Wed, 15 May 2019 10:17:22 GMT"
    }
  },
  "uuid" : "dd73ce40-b33a-46a6-a2a6-eba2d1cea91f",
  "persistent" : true,
  "insertionIndex" : 8
}